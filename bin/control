#!/bin/bash

source $OPENSHIFT_CARTRIDGE_SDK_BASH
. ~/.profile

PLAY2_PID_FILE=${OPENSHIFT_HOMEDIR}/app-root/runtime/play2.pid
CARTRIDGE_TYPE="play2"

function start {
  # Check for running app
  if isrunning; then
      echo "Application is already running"
  else
    cd $OPENSHIFT_REPO_DIR
    # build on first time
    [ -d target ] || build
    rm -f target/universal/stage/RUNNING_PID
    BIN_NAME=$(ls target/universal/stage/bin/ | head -n 1)
    #nohup target/universal/stage/bin/$BIN_NAME -Duser.home=${OPENSHIFT_DATA_DIR} -Dhttp.port=8080 -Dhttp.address=${OPENSHIFT_PLAY2_IP} -DapplyEvolutions.default=true -Dconfig.resource=openshift.conf -mem 512 > $OPENSHIFT_PLAY2_LOG_DIR/play.log 2>&1 &
    echo "Inside start"
    PROCESS_ID=$!
    echo "$PROCESS_ID" > ${PLAY2_PID_FILE}
  fi
}

function stop {
  echo "Stopping $CARTRIDGE_TYPE cart"

  if isrunning; then
    if [ -f "$PLAY2_PID_FILE" ]; then
      PLAY2_PID=$(cat $PLAY2_PID_FILE);
      echo "Sending SIGTERM to $CARTRIDGE_TYPE:$PLAY2_PID ..." 1>&2
      killtree $PLAY2_PID
    else
      echo "Failed to locate $CARTRIDGE_TYPE PID File" 1>&2
    fi
  fi
}

function restart {
    echo "Restarting $CARTRIDGE_TYPE cart"
    stop
    start
}

function build {
    # Workaround for failure in npm install when a package in package.json
    # points to a git commit.
    # This issue occurs because we are running in the context of a
    # git post receive-hook
    unset GIT_DIR
    unset GIT_WORK_TREE

    cd ${PLAY_APPLICATION_PATH}
    echo "JAVA_HOME[${JAVA_HOME}]"
    echo "PATH[${PATH}]"
    echo "PLAY_APPLICATION_PATH[${PLAY_APPLICATION_PATH}]"
    activator clean stage -Duser.home=${OPENSHIFT_DATA_DIR} -mem 750
}

function tidy {
    shopt -s dotglob
    rm -rf $OPENSHIFT_TMP_DIR/*
}

# Check if the play2 process is running
function isrunning() {

    # Check for running app
    if [ -f "$PLAY2_PID_FILE" ]; then
      PLAY2_PID=$(cat $PLAY2_PID_FILE);
      if /bin/ps --pid $PLAY2_PID 1>&2 >/dev/null;
      then
        return 0
      fi
    fi

    return 1
}

function status() {
   if isrunning
   then
      client_result "Application is running"
   else
      client_result "Application is either stopped or inaccessible"
   fi
}


# Kill the process given by $1 and its children
killtree() {
    local _pid=$1
    for _child in $(ps -o pid --no-headers --ppid ${_pid}); do
        killtree ${_child}
    done

    local should_be_gone_pid=$(ps -o pid -p ${_pid} --no-headers)
    if [ -z "$should_be_gone_pid" ]; then
        return
    else
        kill -TERM ${_pid}
    fi

    local count=0
    while [ ${count} -lt 15 ]
    do
        local should_be_gone_pid=$(ps -o pid -p ${_pid} --no-headers)
        if [ -z "$should_be_gone_pid" ]; then
                return
        else
                sleep 2
                let count=${count}+1
        fi
    done

    local should_be_gone_pid=$(ps -o pid -p ${_pid} --no-headers)
    if [ ! -z $should_be_gone_pid ]
    then
        kill -9 ${_pid}
    fi
}

function catchall {
    echo "$1 - Not yet implemented"
}


case "$1" in
  start)       start ;;
  stop)        stop ;;
  restart)     restart ;;
  status)      status ;;
  reload)      catchall "reload";;
  tidy)        tidy ;;
  pre-build)   catchall "pre-build";;
  build)       build ;;
  deploy)      catchall "deploy";;
  post-deploy) catchall "post-deploy";;
  *)           exit 0
esac

exit 0
